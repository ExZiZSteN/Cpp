# Шестаков Михаил ИТ-2 Вариант 5


## Задачи


### Задание 1. Задача 6
`
Даны вектор V, дек D и список L. Каждый исходный контейнер содержит не менее трех элементов,
количество элементов является нечетным. Удвоить значения первого, среднего и последнего
элемента каждого из исходных контейнеров
`

##### Пример 1:
вектор: 1 2 3
дек: 4 5 6
список: 7 8 9

Результат:
вектор: 2 4 6
дек: 8 10 12
список: 14 16 18

##### Пример 2:
вектор: 1 2 3 4 5
дек: 2 3 4 5 6
список: 3 4 5 6 7

Результат:
вектор: 2 4 6 8 10
дек: 4 6 8 10 12
список: 6 8 10 12 14

#### Описание решения
Функция `Double` которая принммает на вход vector/deque/list. Удваивает значения первого, среднего и последнего элеметов.


### Задание 2. Задача 5
`
Даны дек D и список L. Каждый исходный контейнер содержит не менее 5 элементов. Вставить
перед пятым с конца элементом списка последние 5 элементов дека в обратном порядке.
Использовать один вызов функции-члена insert.
`

##### Пример 1:
список: 1 2 3 4 5 6 
дек: 10 11 12 13 14

Результат:
список: 1 14 13 12 11 10 2 3 4 5 6

##### Пример 2:
список: 1 2 3 4 5
дек: 6 7 8 9 10

Результат:
список: 6 7 8 9 10 1 2 3 4 5

#### Описание решения
Функция `fifth_from_end` которая принммает на вход `list` и возваращает итератор, который указывает на 5-ый элемент с конца.
Функция `last_five_from_end` которая принимает на вхож `deque` и возвращает новый `deque` который содержит в себе последние 5 элементов изначального дека, но в обратном порядке.
Через функцию `insert` у `list` вставляем новый дек перед 5-ым элементом списка.

### Задание 3. Задача 11
`
Даны два списка L1 и L2 с одинаковым количеством элементов N. Получить в списке L2
комбинированный набор элементов исходных списков вида A1, B1, A2, B2, A3, B3, …, AN, BN, где
Ai обозначают элементы исходного списка L1, а Bi — элементы исходного списка L2. Для этого
использовать итераторы i1 (для списка L1) и i2 (для списка L2), связав их с первым элементом
соответствующего списка. В цикле, который должен повторяться N раз, вызывать функцию-
член splice для списка L2 с первым параметром ++i2 и третьим параметром i1++.
`

##### Пример 1:
N: 2
L1: 1 3 
L2: 2 4

Результат:
L2: 1 2 3 4

#### Описание решения
Функция `combineList`, которая принимает на вход на спика и вставляет перед каждым элемета из L2 соотвествующий по индексу элеменет из L1. В функции реализован цикл `for`, который повторяется `N` раз. В нем вызывается функция `splice` у `list` с параметрами `it2` - итератор L2, `lst1`, `it1` - итератор L1. 

### Задание 4. Задача 5
`
Дан набор символов. Вывести все символы из исходного набора в том же порядке, заменяя
цифровые символы на символ подчеркивания. Использовать алгоритм replace_copy_if
`

##### Пример 1:
набор: a v 1 c

Результат:
a v _ c

#### Описание решения
Алгоритм `replace_copy_if` с параметрами `ссылка на начало набора`, `ссылка на конец набора`,`выходящий итератор`, `предикат`, `на что меняем`

### Задание 5. Задача 5
`
Дан список L, содержащий как отрицательные, так и положительные элементы. Вставить
нулевой элемент после первого отрицательного элемента и перед последним положительным
элементом. Использовать два вызова алгоритма find_if и два вызова функции-члена insert.
Указание. По поводу использования алгоритма find_if с обратным итератором см. указание к
задаче 5.2
`

##### Пример 1:
набор: a v 1 c

Результат:
a v _ c

#### Описание решения
Алгоритм `replace_copy_if` с параметрами `ссылка на начало набора`, `ссылка на конец набора`,`выходящий итератор`, `предикат`, `на что меняем`

### Задание 6. Задача 5
`
Даны списки L1 и L2, каждый из которых содержит четное количество элементов. Поменять
местами первую и вторую половину каждого списка (например, список 1, 2, 3, 4 должен быть
преобразован следующим образом: 3, 4, 1, 2). Для первого списка использовать алгоритм
swap_ranges, для второго — алгоритм rotate. Использовать также функцию advance
`

##### Пример 1:
L1: 1 2 3 4
L2: 5 6 7 8

Результат:
L1: 3 4 1 2
L2: 7 8 5 6

#### Описание решения
Алгоритм `swap_ranges` для L1 на вход которому три параметра первый итератор `first1`, который указывавет на `L1.begin()`,второй `last1` который на среднем элементе, `first2`. Получаем два renga первый [first1,last2], второй [first2,last1-first1]
Алгоритм `rotate` который меняет элеметы до середины с элементами после середины

### Задание 7. Задача 2
`
Дан вектор V, содержащий не менее 3 элементов. Определить значения трех начальных
элементов вектора после того, как вектор будет отсортирован (по возрастанию), и вывести их в
порядке возрастания. Использовать один вызов алгоритма partial_sort и алгоритм copy для
вывода требуемых элементов
`

##### Пример 1:
vector: 5 2 1

Результат:
1 2 5

##### Пример 2:
vector: 10 4 7 2 0 5

Результат:
0 2 4 

#### Описание решения
Алгоритм `sort` сортируем `vector` по возрастанию.
Алгоритм `copy` копируем первые 3 элеметна отсрортированного `vector` в новый и вывыодим.


### Задание 8. Задача 2
`
Дан список L, элементами которого являются английские слова. Получить дек D со строковыми
элементами, каждый из которых строится по паре соседних элементов исходного списка L
следующим образом: последняя буква правого элемента пары приписывается справа к первой
букве левого элемента пары. Количество элементов дека D должно быть на 1 меньше
количества элементов списка L. Например, для исходного списка ABC, DEF, KLM, XYZ
полученный дек должен содержать строки AF, DM, KZ. Использовать алгоритм
adjacent_difference с итератором вставки и функциональным объектом, а также функцию-член
erase для дека D
`

##### Пример 1:
list: ABC, DEF, KLM, XYZ

Результат:
AF DM KZ


#### Описание решения
Алгоритм `adjacent_differnce`.Склеиваем переменные берем первую букву левого элемента + последнюю букву правого элемента. Добавляем это в `deque`

### Задание 9. Задача 1
`
Дан вектор V0, целое число N (> 0) и набор векторов V1, …, VN. Известно, что размер вектора V0
не превосходит размера любого из векторов V1, …, VN. Найти количество векторов VI, I = 1, …, N,
в которых содержатся все элементы вектора V0 (без учета их повторений). Использовать
алгоритм includes, применяя его в цикле к двум множествам, одно из которых создано на основе
вектора V0, а другое на очередной итерации содержит элементы очередного из векторов VI, I =
1, …, N
`

##### Пример 1:
list: ABC, DEF, KLM, XYZ

Результат:
AF DM KZ


#### Описание решения
Алгоритм `adjacent_differnce`.Склеиваем переменные берем первую букву левого элемента + последнюю букву правого элемента. Добавляем это в `deque`
